!!****if* source/Simulation/SimulationMain/Sedov/Simulation_computeAnalytical
!!
!! NAME
!!
!!  Simulation_computeAnalytical
!!
!!
!! SYNOPSIS
!!
!!  call Simulation_computeAnalytical(integer(IN) :: blockID, 
!!                                    real(IN)    :: tcurr)
!!
!!
!!
!! DESCRIPTION
!!
!!  Compute an analytical solution for
!!  a specified block.
!! 
!! ARGUMENTS
!!
!!  blockID -        the number of the block to initialize
!!  tcurr   -        current time
!!
!!
!! SIDE EFFECTS
!!
!!  The analytical solution is computed and stored in the appropriate slots
!!  in the solution vector, UNK.
!!
!!  In this implementation, the following UNK variables are set:
!!     !!DEV : changed UNK variables - to be documented.
!!
!!***

!!REORDER(4): solnData

subroutine Simulation_computeAnalytical(solnData, tileDesc, tcurr)

  use Simulation_data, ONLY: sim_xMax, sim_xMin, sim_yMax, sim_yMin, sim_zMax, sim_zMin, &
     &  sim_nProfile, sim_rProf, sim_vProf, sim_pProf, sim_pExp, sim_rhoProf, &
     &  sim_tInitial, sim_gamma, sim_expEnergy, sim_pAmbient, sim_rhoAmbient, &
     &  sim_analyticTime, sim_analyticGen,          &
     &  sim_useProfileFromFile, sim_profileInitial, &
     &  sim_smallX, sim_smallRho, sim_minRhoInit, sim_smallP, sim_rInit, &
     &  sim_smallT, &
     &  sim_nSubZones, sim_xCenter, sim_yCenter, sim_zCenter, sim_inSubzones, sim_inszd, &
     sim_threadBlockList, sim_threadWithinBlock
  use Driver_data,         ONLY : dr_simGeneration
  use Grid_interface,   ONLY : Grid_getCellCoords, Grid_getSingleCellVol, Grid_subcellGeometry
  use Grid_tile,        ONLY : Grid_tile_t 
  use Driver_interface, ONLY : Driver_getSimTime
  use Timers_interface, ONLY : Timers_start, Timers_stop
  use ut_interpolationInterface


  implicit none

#include "constants.h"
#include "Flash.h"
!#include "Eos.h"   
#include "FortranLangFeatures.fh"

  
  real,dimension(:,:,:,:),POINTER_INTENT_IN :: solnData
  type(Grid_tile_t), intent(in) :: tileDesc
  real,    intent(in) :: tcurr

  integer,parameter :: op = 2
  integer :: i, j, k, jLo, jHi
  integer  ::  ii, jj, kk, kat
  integer  ::  simGen
  real     ::  drProf
  real     ::  distInv, xDist, yDist, zDist
  real     ::  sumRho, sumP, sumVX, sumVY, sumVZ
  real     ::  vel, diagonal
  real     ::  xx, dxx, yy, dyy, zz, dzz, frac
  real     ::  vx, vy, vz, p, rho, e, ek, eint
  real     ::  dist
  real     ::  vSub, rhoSub, pSub, errIgnored
  real     ::  simTime
  real,allocatable,dimension(:) :: xCoord,yCoord,zCoord
  integer, dimension(2,MDIM) :: tileLimits, grownTileLimits

!!$  real     :: dvSub(0:sim_nSubZones-1,0:(sim_nSubZones-1)*K2D)
  real,allocatable :: dvSub(:,:)
  real     :: dvc, quotinv

  logical :: gcell = .true.


  if (tcurr == sim_analyticTime) then
     call Driver_getSimTime(simTime, simGen)
     if (simTime == sim_analyticTime) then
        if (simGen == sim_analyticGen) then
           ! analytical solution is already computed for the current time, and
           ! per (simGen test) the grid does not seem to have changed -
           RETURN               ! return immediately
        end if
     end if
  end if


!!$  call Timers_start("computeAna 1")

  if (sim_useProfileFromFile) then
  ! Prepare the solution that has been read in for use in interpolation
     if (sim_tinitial > 0.0) call sim_scaleProfile(tcurr) ! DEV: Is tcurr right time?
  else
  !
  !  Construct the radial samples needed for the initialization.
  !
     diagonal = (sim_xMax-sim_xMin)**2
     diagonal = diagonal + K2D*(sim_yMax-sim_yMin)**2
     diagonal = diagonal + K3D*(sim_zMax-sim_zMin)**2
     diagonal = sqrt(diagonal)
  
     drProf = diagonal / (sim_nProfile-1)
  
     do i = 1, sim_nProfile
        sim_rProf(i)   = (i-1) * drProf
     enddo
  !
  !  Use the analytic Sedov solution implemented in Simulation_initBlock,
  !  WHICH IS WRONG.
  !
     call set_analytic_sedov (sim_nProfile, sim_rProf, sim_rhoProf, sim_pProf, & 
          sim_vProf, tcurr, sim_gamma, sim_expEnergy, & 
          sim_pAmbient, sim_rhoAmbient)
  end if                        !useProfileFromFile

!!$  call Timers_stop("computeAna 1")
!!$  call Timers_start("computeAna 2")

  ! get the coordinate information for the current block

  tileLimits =   tileDesc % limits
  grownTileLimits = tileDesc % grownLimits 

  allocate(xCoord(grownTileLimits(LOW, IAXIS):grownTileLimits(HIGH, IAXIS)))
  allocate(yCoord(grownTileLimits(LOW, JAXIS):grownTileLimits(HIGH, JAXIS)))
  allocate(zCoord(grownTileLimits(LOW, KAXIS):grownTileLimits(HIGH, KAXIS)))
  xCoord(:) = 0.0
  yCoord(:) = 0.0
  zCoord(:) = 0.0

  call Grid_getCellCoords(IAXIS, CENTER, tileDesc%level, &
                          grownTileLimits(LOW, :), grownTileLimits(HIGH, :), &
                          xCoord)
#if NDIM >= 2
  call Grid_getCellCoords(JAXIS, CENTER, tileDesc%level, &
                          grownTileLimits(LOW, :), grownTileLimits(HIGH, :), &
                          yCoord)
#endif
#if NDIM == 3
  call Grid_getCellCoords(KAXIS, CENTER, tileDesc%level, &
                          grownTileLimits(LOW, :), grownTileLimits(HIGH, :), &
                          zCoord)
#endif

  !
  !     For each cell
  !  

  !There is no parallel region in Grid_initDomain or other code from
  !which this routine is expected to be called, and so we use the
  !same thread within block code for both multithreading strategies.

  !$omp parallel if (sim_threadBlockList .or. sim_threadWithinBlock) &
  !$omp default(none) &
  !$omp shared(tileLimits,grownTileLimits,xCoord,yCoord,zCoord,&
  !$omp sim_inSubzones,sim_nSubZones,sim_rProf,sim_minRhoInit,sim_smallRho,sim_smallP,&
  !$omp sim_smallX,sim_pProf,sim_rhoProf,sim_vProf,sim_gamma,sim_inszd,&
  !$omp sim_smallT,&
  !$omp sim_useProfileFromFile,errIgnored,solnData, &
  !$omp sim_rhoAmbient,sim_pAmbient, &
  !$omp sim_xCenter,sim_yCenter,sim_zCenter) &
  !$omp private(i,j,k,ii,jj,kk,dxx,dyy,dzz,sumRho,sumP,sumVX,sumVY,sumVZ,&
  !$omp xx,yy,zz,xDist,yDist,zDist,dist,distInv,jLo,jHi,frac,vel,&
  !$omp rho,p,vx,vy,vz,ek,e,eint,kat,rhoSub,pSub,vSub,dvc,quotinv,dvSub)

  allocate(dvSub(0:sim_nSubZones-1,0:(sim_nSubZones-1)*K2D))

#if NDIM == 3
  !$omp do schedule(static)
#endif
  do k = tileLimits(LOW,KAXIS), tileLimits(HIGH,KAXIS)
     ! Find a real difference between z's if problem is >= 3D
     if (NDIM > 2) then
        if (k .eq. grownTileLimits(LOW,KAXIS)) then
           dzz = zCoord(grownTileLimits(LOW,KAXIS)+1) - zCoord(grownTileLimits(LOW,KAXIS))
        else
           dzz = zCoord(k) - zCoord(k-1) 
        endif
     ! Otherwise this problem is <= 2D, so dzz is meaningless
     else
       dzz = 0.0
     endif
     zz = zCoord(k)

#if NDIM == 2
     !$omp do schedule(static)
#endif
     do j = tileLimits(LOW, JAXIS), tileLimits(HIGH, JAXIS)
        ! Find a real difference between y's if problem is >= 2D
        if (NDIM > 1) then
           if (j .eq. grownTileLimits(LOW,JAXIS)) then
              dyy = yCoord(grownTileLimits(LOW,JAXIS)+1) - yCoord(grownTileLimits(LOW,JAXIS))
           else
              dyy = yCoord(j) - yCoord(j-1) 
           endif
        ! Otherwise this problem is <= 1D, so dyy is meaningless
        else
          dyy = 0.0
        endif
        yy = yCoord(j)
        
#if NDIM == 1
        !$omp do schedule(static)
#endif
        do i = tileLimits(LOW,IAXIS), tileLimits(HIGH, IAXIS)
           xx = xCoord(i)
           if (i .eq. grownTileLimits(LOW,IAXIS)) then
              dxx = xCoord(grownTileLimits(LOW,IAXIS)+1) - xCoord(grownTileLimits(LOW,IAXIS))
           else
              dxx = xCoord(i) - xCoord(i-1) 
           endif
           
           call Grid_getSingleCellVol((/i,j,k/), tileDesc%level, dvc)
           call Grid_subcellGeometry(sim_nSubZones,1+(sim_nSubZones-1)*K2D,1+(sim_nSubZones-1)*K3D, &
                dvc, dvSub, xCoord(i)-0.5*dxx, xCoord(i)+0.5*dxx )


           sumRho = 0.
           sumP   = 0.
           sumVX  = 0.
           sumVY  = 0.
           sumVZ  = 0.
           
           !
           !       Break the cell into sim_nSubZones^NDIM sub-zones, and look up the
           !       appropriate quantities along the 1d profile for that subzone.  
           !
           !       Have the final values for the zone be equal to the average of
           !       the subzone values.
           ! 

           do kk = 0, (sim_nSubZones-1)*K3D
              zz    = zCoord(k) + ((real(kk)+0.5)*sim_inSubzones-.5)*dzz 
              zDist = (zz - sim_zCenter) * K3D
              
              do jj = 0, (sim_nSubZones-1)*K2D
                 yy    = yCoord(j) + ((real(jj)+0.5)*sim_inSubzones-.5)*dyy
                 yDist = (yy - sim_yCenter) * K2D
                 
                 do ii = 0, (sim_nSubZones-1)
                    xx    = xCoord(i) + ((real(ii)+0.5)*sim_inSubzones-.5)*dxx
                    xDist = xx - sim_xCenter
                    
                    dist    = sqrt( xDist**2 + yDist**2 + zDist**2 )
                    distInv = 1. / max( dist, 1.E-10 )
                    if (sim_useProfileFromFile) then
                       if (dist .LE. sim_rProf(sim_nProfile+1)) then
                          call ut_hunt(sim_rProf,sim_nProfile+1,dist,kat)
                          kat = max(1, min(kat - op/2 + 1, sim_nProfile - op + 2))
                          call ut_polint(sim_rProf(kat),sim_vProf  (kat),op,dist,vSub  ,errIgnored)
                          call ut_polint(sim_rProf(kat),sim_rhoProf(kat),op,dist,rhoSub,errIgnored)
                          call ut_polint(sim_rProf(kat),sim_pProf  (kat),op,dist,pSub  ,errIgnored)
                       else
                          vSub    = 0.0
                          rhoSub  = sim_rhoAmbient
                          psub    = sim_pAmbient
                       end if
                    else
                       call sim_find (sim_rProf, sim_nProfile, dist, jLo)
                    !
                    !  a point at `dist' is frac-way between jLo and jHi.   We do a
                    !  linear interpolation of the quantities at jLo and jHi and sum those.
                    ! 
                       if (jLo .eq. 0) then
                          jLo = 1
                          jHi = 1
                          frac = 0.
                       else if (jLo .eq. sim_nProfile) then
                          jLo = sim_nProfile
                          jHi = sim_nProfile
                          frac = 0.
                       else
                          jHi = jLo + 1
                          frac = (dist - sim_rProf(jLo)) / & 
                            (sim_rProf(jHi)-sim_rProf(jLo))
                       endif

                       pSub   =  sim_pProf(jLo) + frac*(sim_pProf(jHi)  - sim_pProf(jLo))

                       rhoSub =  sim_rhoProf(jLo) + frac*(sim_rhoProf(jHi)- sim_rhoProf(jLo))
                       rhoSub = max(rhoSub, sim_minRhoInit)

                       vSub   = sim_vProf(jLo) + frac*(sim_vProf(jHi)  - sim_vProf(jLo))

                    end if
                    ! 
                    !   Now total these quantities.   Note that  v is a radial velocity; 
                    !   we multiply by the tangents of the appropriate angles to get
                    !   the projections in the x, y and z directions.
                    !
                    sumP = sumP + pSub * dvSub(ii,jj)
                    
                    sumRho = sumRho + rhoSub * dvSub(ii,jj)
                    
                    vel = vSub * dvSub(ii,jj)
                    
                    sumVX  = sumVX  + vel*xDist*distInv
                    sumVY  = sumVY  + vel*yDist*distInv
                    sumVZ  = sumVZ  + vel*zDist*distInv
                    
                 enddo
              enddo
           enddo
           
!!$           quotinv = sim_inszd
           quotinv = 1.0 / dvc
           rho = max(sumRho * quotinv, sim_smallRho)
           p   = max(sumP   * quotinv, sim_smallP)
           vx  = sumVX  * quotinv
           vy  = sumVY  * quotinv
           vz  = sumVZ  * quotinv
           ek  = 0.5*(vx*vx + vy*vy + vz*vz)
           !
           !  assume gamma-law equation of state
           !
           e   = p/(sim_gamma-1.)
           eint= e/rho
           e   = e/rho + ek
           e   = max (e, sim_smallP)
           

!!$           if (NSPECIES > 0) then
!!$              solnData(SPECIES_BEGIN,i,j,k)=1.0-(NSPECIES-1)*sim_smallX
!!$              solnData(SPECIES_BEGIN+1:SPECIES_END,i,j,k)=sim_smallX
!!$           end if
!!$           solnData(DENS_VAR,i,j,k)=rho
!!$           solnData(PRES_VAR,i,j,k)=p
!!$           solnData(ENER_VAR,i,j,k)=e
!!$#ifdef EINT_VAR
!!$           solnData(EINT_VAR,i,j,k)=eint
!!$#endif
!!$           solnData(GAME_VAR,i,j,k)=sim_gamma
!!$           solnData(GAMC_VAR,i,j,k)=sim_gamma
!!$           solnData(VELX_VAR,i,j,k)=vx
!!$           solnData(VELY_VAR,i,j,k)=vy
!!$           solnData(VELZ_VAR,i,j,k)=vz
!!$           solnData(TEMP_VAR,i,j,k)=sim_smallT

           solnData(DENA_VAR,i,j,k)=rho
           solnData(PRSA_VAR,i,j,k)=p
#ifdef ENRA_VAR
           solnData(ENRA_VAR,i,j,k)=e
#endif
#ifdef EINA_VAR
           solnData(EINA_VAR,i,j,k)=eint
#endif
           solnData(VLXA_VAR,i,j,k)=vx
#ifdef VLYA_VAR
           solnData(VLYA_VAR,i,j,k)=vy
#endif
#ifdef VLZA_VAR
           solnData(VLZA_VAR,i,j,k)=vz
#endif
        enddo
#if NDIM == 1
  !$omp end do nowait
#endif
     enddo
#if NDIM == 2
  !$omp end do nowait
#endif
  enddo
#if NDIM == 3
  !$omp end do nowait
#endif
  deallocate(dvSub)
  !$omp end parallel


  deallocate(xCoord)
  deallocate(yCoord)
  deallocate(zCoord)

  sim_analyticTime = tcurr

!!$  call Timers_stop("computeAna 2")

end subroutine Simulation_computeAnalytical
