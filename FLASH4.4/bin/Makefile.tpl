## Lines starting with ## are comments inside template file
## All other lines including empty lines are non-comments
## 
## This file is a template for Generating the BuildStamp script
## For syntax of this file see "Readme.template"
##
## VALID VARIABLE NAMES FOR THIS MAKEFILE TEMPLATE
##
## makedisplay  -> 0 or 1 depending on whether user wants make to print commands
##                it is executing
## indexReorder -> 0 or 1 depending on whether we want to switch order of indices in unk
## useopenmp    -> 0 or 1 depending on whether certain setup variables with names like 
##                 thread{BlockList,WithinBlock,RayTrace,ProtonTrace} are of Boolean
##                 type and True.
## ndim         -> the dimension of the simulation to build
## includeTAU   -> ???
## pdbvar
## pdbrule
## cDefines     -> Flags passed to C compiler
## fDefines     -> flags passed to fortran compiler
## flagRedirect -> Several lines that will define FFLAGS, CFLAGS, LFLAGS, and LIBS
##                 as concatenations of other symbols like FFLAGS_HYPRE FFLAGS_DEBUG etc.
##                 The set of symbols which are concatenated can depend on LIBRARY
##                 statements in Config files parsed by setup, definitions found
##                 in Makefile.h, and on whcih of the floags {-debug,-test,-test}
##                 was active for setup.
## includeList  -> Commands to include relavant Makefiles
## includeMacros-> include Macros
## dependFlags  -> extra flags for setup_depends.py
##
## NO other variables may be used with %(VARNAME)[sd] syntax

#  Makefile for FLASH code.  Automatically generated by setup script.
#  Do not edit!

MAKEDISPLAY = %(makedisplay)d
REORDERFLAG = %(indexReorder)d
FLASHBINARY = true
USEOPENMP = %(useopenmp)d
NDIM = %(ndim)d

# -s => Do not print the actual command being executed
# -r => Do not use any implicit rules (speeds up performance)
# -d => Print debugging information on how make is making decisions
ifeq ("$(MAKEDISPLAY)","1")
MAKEFLAGS = 
else
MAKEFLAGS = -s 
endif

EXE = flash4

.PHONY: default

default: $(EXE)


#\tMachine-dependent include file

CDEFINES = %(cDefines)s
FDEFINES = %(fDefines)s

#\tprint the compiler flags to file in FLASH/object/
#\t(files name are also hard-coded into make_bstats)

PRINT_F77_FLAGS = @$(ECHO) F77: $(FCOMP) $(FFLAGS) $(F77FLAGS) $(FDEFINES)
PRINT_F90_FLAGS = @$(ECHO) F90: $(FCOMP) $(FFLAGS) $(F90FLAGS) $(FDEFINES)
PRINT_C_FLAGS = @$(ECHO) C: $(CCOMP) $(CFLAGS) $(CDEFINES)
PRINT_L_FLAGS = @$(ECHO) Linker: $(LINK) $(LFLAGS) $(EXE) \(Object files of units\) $(LIB) $(CONFIG_LIB)
PRINT_FLAGS_FILE = setup_flags
SUCCESS_FILE = .success

include Makefile.h


# define touch and mv command if not already defined in Makefile.h
TOUCH ?= touch
MV ?= mv

%(flagRedirect)s

ifeq ("$(USEOPENMP)","1")
#In most cases we can just define a variable named OPENMP in our Makefile.h.
#This is not always possible when we mix compilers, e.g. absoft (for Fortran)
#which uses '-openmp' and gcc (for C) which uses '-fopenmp' - in this
#situation we would define OPENMP_FORTRAN, OPENMP_C and OPENMP_LINK.
ifdef OPENMP_FORTRAN
FFLAGS := $(OPENMP_FORTRAN) $(FFLAGS)
else
FFLAGS := $(OPENMP) $(FFLAGS)
endif

ifdef OPENMP_C
CFLAGS := $(OPENMP_C) $(CFLAGS)
else
CFLAGS := $(OPENMP) $(CFLAGS)
endif

ifdef OPENMP_LINK
LFLAGS := $(OPENMP_LINK) $(LFLAGS)
else
LFLAGS := $(OPENMP) $(LFLAGS)
endif
endif

ifeq ("$(MAKEDISPLAY)","0")
define ECHO-COMPILING
@$(ECHO) Compiling $<
endef
else
define ECHO-COMPILING
endef
endif

ifeq ("$(MAKEDISPLAY)","0")
define ECHO-PROCESSING
@$(ECHO) Processing $<
endef
else
define ECHO-PROCESSING
endef
endif

#\tCompile



.SUFFIXES:

.SUFFIXES: .f .F .f90 .F90 .c .C .cxx .o .cu
  
%%.o : %%.f
\t$(ECHO-COMPILING) 
\t$(FCOMP) $(FFLAGS) $(f77FLAGS) $(FDEFINES) $< -o $(addsuffix .o,$(basename $@))
%%.o : %%.F
\t$(ECHO-COMPILING) 
\t$(FCOMP) $(FFLAGS) $(F77FLAGS) $(FDEFINES) $< -o $(addsuffix .o,$(basename $@))
%%.o : %%.f90
\t$(ECHO-COMPILING) 
\t$(FCOMP) $(FFLAGS) $(f90FLAGS) $(FDEFINES) $< -o $(addsuffix .o,$(basename $@))
%%.o %%.mod : %%.F90
\t$(ECHO-COMPILING) 
\t$(FCOMP) $(FFLAGS) $(F90FLAGS) $(FDEFINES) $< -o $(addsuffix .o,$(basename $@))
ifdef MODUPPERCASE
\t-$(if $(wildcard $*.mod),if [ -w $*.mod -a -s $(shell echo $*|tr a-z A-Z).mod -a \( $(shell echo $*|tr a-z A-Z).mod -nt $*.mod \) ] ;then ln -f $(shell echo $*|tr a-z A-Z).mod $*.mod;fi)
else
\t-$(if $(wildcard $*.mod),if [ -w $*.mod -a -s $(shell echo $*|tr A-Z a-z).mod -a \( $(shell echo $*|tr A-Z a-z).mod -nt $*.mod \) ] ;then ln -f -v $(shell echo $*|tr A-Z a-z).mod $*.mod;else test -f $@ -a -s $@ -a -w $@&&touch $@||:;fi)
endif
%%.o : %%.c
\t$(ECHO-COMPILING) 
\t$(CCOMP) $(CFLAGS) $(CDEFINES) $< -o $(addsuffix .o,$(basename $@))
%%.o : %%.C
\t$(ECHO-COMPILING) 
\t$(CPPCOMP) $(CFLAGS) $(CDEFINES) $< -o $(addsuffix .o,$(basename $@))
%%.o : %%.cxx
\t$(ECHO-COMPILING) 
\t$(CPPCOMP) $(CFLAGS) $(CDEFINES) $< -o $(addsuffix .o,$(basename $@))
%%.o : %%.cu
\t$(ECHO-COMPILING)
\t$(CUCOMP) $(CU_FLAGS) $(CDEFINES) $< -o $(addsuffix .o,$(basename $@))
%%API.c %%API.h %%API-bridges.F90: %%.int
\t$(ECHO-PROCESSING) 
\t./int2API.py $<

.PRECIOUS: %%API.c %%API.h %%API-bridges.F90

# What to do in case we are unable to build an object file

MKFILES = $(shell grep -l $(1) Makefile.* | egrep -v "Makefile.Depend")
UNITNAMES = $(patsubst Makefile.%%,%%,$(1))
SRCFILES = $(shell ls | grep -i $(basename $(1))\\.)

.DEFAULT:
\t@$(ECHO) Sorry, I am unable to build $@ mentioned in $(call MKFILES,$@)
\t@$(ECHO) Related directory contents: $(call SRCFILES,$@)
\t@$(ECHO) If you do not see an appropriate source file, $@ is probably mentioned in the
\t@$(ECHO) wrong Makefile and should probably go deeper inside the $(call UNITNAMES,$(call MKFILES,$@)) unit
\t@$(RM) -f $(SUCCESS_FILE)
\t@exit 1

#       Setup_buildstamp routine

.PHONY: setup_buildstamp.F90

setup_buildstamp.F90: 
\t@$(ECHO) Generating Buildstamp
\t./make_bstamp

#       Release routine

.PHONY: setup_flashRelease.F90

setup_flashRelease.F90: 
\t@$(ECHO) Generating Flash Release
\t./make_release

#       Build statistics routine

.PHONY: setup_buildstats.c

setup_buildstats.c: 
\t@$(ECHO) Generating Build Statistics
\t./make_bstats

# Make the Makefile.Depend 
Makefile.Depend: 
\t@$(ECHO) Calculating dependencies
\t./setup_depends.py %(dependFlags)s $(FFLAGS) $(F90FLAGS) $(CFLAGS) *.f *.f90 *.F90 *.F 
\t./setup_addcdepends.py $(CFLAGS) *.c *.cu

.PHONY: reorder
# run reorder script or kill the script if we dont need it
ifeq ("$(REORDERFLAG)","1")
reorder: Makefile.Depend
\tbash reorder.sh
else
reorder:
\trm -f reorder.sh
endif

.PHONY: reorderclean
ifeq ("$(REORDERFLAG)","1")
\tbash reorder.sh --clean
endif

#\tFLASH Units routine

# include Dependency information
# the -include supresses the warning if Makefile.Depend is not found

-include Makefile.Depend

%(taumakeline)s
%(tauinserts)s

#\tUnit Makefiles

MISC_OBJS = $(MACHOBJ) setup_buildstamp.o setup_flashRelease.o setup_buildstats.o setup_getFlashUnits.o 

%(includeList)s
ALL_OBJ_FILES = \\%(includeMacros)s
       $(MISC_OBJS) 

#Remove duplicate names (side effect is sorting)
ALL_OBJS = $(sort $(ALL_OBJ_FILES))

# DATA_OBJS contains all object files which define modules, rest are CODE_OBJS
# CODE_OBJS = ALL_OBJS - DATA_OBJS
CODE_OBJS = $(filter-out $(DATA_OBJS),$(ALL_OBJS))

#\tLink
.PHONY: printflags
printflags:
ifeq ("$(MAKEDISPLAY)","0")
\t@$(ECHO) Compiler and Flags Info follows
\t$(PRINT_F77_FLAGS)
\t$(PRINT_F90_FLAGS)
\t$(PRINT_C_FLAGS)
\t$(PRINT_L_FLAGS)
endif
\t@$(RM) $(PRINT_FLAGS_FILE)
\t@$(RM) -f $(SUCCESS_FILE)
\t@$(TOUCH) $(PRINT_FLAGS_FILE)
\t$(PRINT_F77_FLAGS) >> $(PRINT_FLAGS_FILE)
\t@$(ECHO)  >> $(PRINT_FLAGS_FILE)
\t$(PRINT_F90_FLAGS) >> $(PRINT_FLAGS_FILE)
\t@$(ECHO)  >> $(PRINT_FLAGS_FILE)
\t$(PRINT_C_FLAGS) >> $(PRINT_FLAGS_FILE)
\t@$(ECHO)  >> $(PRINT_FLAGS_FILE)
\t$(PRINT_L_FLAGS) >> $(PRINT_FLAGS_FILE)
\t@$(ECHO)  >> $(PRINT_FLAGS_FILE)
\t@$(ECHO) Data Object files: >> $(PRINT_FLAGS_FILE)
\t@$(ECHO) $(DATA_OBJS) >> $(PRINT_FLAGS_FILE)
\t@$(ECHO)  >> $(PRINT_FLAGS_FILE)
\t@$(ECHO) Code Object files: >> $(PRINT_FLAGS_FILE)
\t@$(ECHO) $(CODE_OBJS) >> $(PRINT_FLAGS_FILE)

.PHONY: data code clean distclean

data: $(DATA_OBJS)

code: data $(CODE_OBJS) 

$(EXE) : printflags reorder data code
\t@$(ECHO) Linking in Units and Libraries 
\t$(LINK) $(LFLAGS) $(EXE) $(ALL_OBJS) $(LIB) $(CONFIG_LIB)
\t@$(ECHO) SUCCESS
\t@$(TOUCH) $(SUCCESS_FILE)

#\tClean up object directory

clean:
\t$(RM) $(PRINT_FLAGS_FILE) *.o *.mod *.a *.unit *API.h *API.c *API-bridges.F90

distclean: clean reorderclean
\t$(RM) Makefile.Depend

precision_test: precision_test.o
\t$(LINK) $(LFLAGS) precision_test precision_test.o

